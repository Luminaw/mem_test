# Project Documentation: User-Mode Memory Test

This document provides a comprehensive overview of the User-Mode Memory Test application, a C++ tool for RAM diagnostics.

**GitHub Repository:** [https://github.com/Luminaw/mem_test](https://github.com/Luminaw/mem_test)

## 1. Introduction

The User-Mode Memory Test is a console-based utility designed to test the integrity of a system's Random Access Memory (RAM). It operates entirely in user mode, meaning it does not require special privileges or kernel-level drivers to run. The application works by allocating a significant block of memory, writing various test patterns to it, and then reading the data back to verify its integrity.

This tool is particularly useful for system builders, overclockers, and technicians who need to validate memory stability under load. By using multiple threads, it can stress the memory controller and individual memory modules effectively.

## 2. Core Features

- **Configurable Test Parameters:** Users can specify the size of the memory block to test (in megabytes) and the number of times the test suite should be repeated.
- **Multi-threaded Architecture:** The application automatically detects the number of available CPU cores (hardware threads) and creates a corresponding number of worker threads. This parallel approach ensures that the memory is tested as quickly and thoroughly as possible.
- **Comprehensive Test Suite:** A variety of data patterns are used to maximize the chances of detecting different kinds of memory errors.
- **Real-time Progress and Feedback:** A progress bar is displayed for each test, providing immediate visual feedback.
- **Detailed Error Reporting:** In case of a memory mismatch, the program halts and provides the exact memory index, the expected data, and the actual data found. This is crucial for diagnosing the nature of the failure.
- **Performance Measurement:** The tool reports the duration of each test iteration and the total time taken, which can be useful for comparing system performance.

## 3. How It Works: Technical Deep Dive

### 3.1. Initialization

1.  **User Input:** The `main` function begins by prompting the user for the memory block size (in MB) and the number of test iterations.
2.  **Parameter Validation:** It checks to ensure that both inputs are positive values.
3.  **Thread Detection:** It calls `std::thread::hardware_concurrency()` to determine the optimal number of threads to use. If this value cannot be determined, it defaults to a single thread.
4.  **RNG Setup:** A `std::mt19937` Mersenne Twister random number generator is seeded with `std::random_device` for the random pattern test.

### 3.2. The Worker Thread (`workerThread`)

The core of the application is the `workerThread` function. The main thread creates and launches one `workerThread` for each available CPU core.

1.  **Memory Partitioning:** The total memory block (`blockSizeBytes`) is divided equally among the worker threads. Each thread is assigned a `start` and `end` index defining its portion of the memory.
2.  **Local Buffer:** Each thread allocates its own `std::vector<char>` buffer. This is a key design point: the memory is allocated on the heap by each thread, but the total size is what the user specifies.
3.  **Test Execution:** Each thread executes a series of test functions on its memory partition sequentially.
4.  **Synchronization:** A `std::mutex` (`progress_mutex`) is used to synchronize console output (`std::cout`) for the progress bar, preventing garbled text. A boolean flag `overallSuccess` is passed by reference to all threads, allowing any thread to signal a failure to the entire application.

### 3.3. Memory Test Patterns

The following test functions are called by each worker thread:

#### a. `runMemoryTestChunk`
This function tests fixed bit patterns. It is called four times with the following patterns:
- **`0xAA` (10101010):** Alternating bits.
- **`0x55` (01010101):** The inverse of `0xAA`.
- **`0xFF` (11111111):** All bits set to 1.
- **`0x00` (00000000):** All bits set to 0.

These patterns are effective at detecting "stuck-at" faults, where a memory bit is permanently stuck in a high or low state.

#### b. `runIncrementingMemoryTestChunk`
This function writes a unique, incrementing value to each byte. The value is calculated as `(i + start) % 256`, where `i` is the current index and `start` is the beginning of the thread's memory chunk. This test is designed to detect addressing faults, where writing to one address incorrectly modifies another.

#### c. `runRandomMemoryTestChunk`
This function performs the most rigorous test:
1.  It creates a temporary `std::vector<char>` called `original_values` to store a copy of the random data.
2.  It fills both the main buffer and `original_values` with random bytes generated by the `std::mt19937` engine.
3.  It then verifies the main buffer's content against the `original_values` vector.

This test is excellent for finding complex, data-sensitive errors that might not appear with predictable patterns.

## 4. Building the Application

### 4.1. Windows (Visual Studio)

The repository includes a Visual Studio 2019 (or later) solution.
1.  Clone the repository: `git clone https://github.com/Luminaw/mem_test.git`
2.  Open the `mem_test.sln` file in Visual Studio.
3.  Select the `Release` and `x64` configuration.
4.  From the menu, select `Build > Build Solution` (or press F7).
5.  The compiled executable (`mem_test.exe`) will be in the `x64/Release` directory.

### 4.2. Linux / macOS (g++)

You can compile the project using a standard C++ compiler like g++.
1.  Clone the repository: `git clone https://github.com/Luminaw/mem_test.git`
2.  Navigate to the project directory: `cd mem_test`
3.  Compile the source code:
    ```bash
    g++ -std=c++17 -O2 -pthread mem_test/mem_test.cpp -o mem_test
    ```
    - `-std=c++17`: Specifies the C++17 standard.
    - `-O2`: Enables optimizations.
    - `-pthread`: Links the pthreads library, necessary for `std::thread`.

## 5. Usage Guide

Run the executable from your command line.

```bash
./mem_test
```

The application will then interactively prompt you for the required parameters.

### Example Session

```
User-Mode Memory Test
----------------------
Enter block size in MB (e.g., 100 for 100MB): 1024
Enter number of iterations: 3

Starting memory test with:
  Block Size: 1024 MB (1073741824 bytes)
  Iterations: 3
  Using 12 threads

--- Iteration 1 ---
  Pattern 0xAA (Write): [================================================>] 100%
  Pattern 0xAA (Verify): [================================================>] 100%
  Pattern 0x55 (Write): [================================================>] 100%
  Pattern 0x55 (Verify): [================================================>] 100%
  Pattern 0xFF (Write): [================================================>] 100%
  Pattern 0xFF (Verify): [================================================>] 100%
  Pattern 0x00 (Write): [================================================>] 100%
  Pattern 0x00 (Verify): [================================================>] 100%
  Incrementing (Write): [================================================>] 100%
  Incrementing (Verify): [================================================>] 100%
  Random (Write):       [================================================>] 100%
  Random (Verify):      [================================================>] 100%
Iteration 1 completed in 15234.56 ms.

... (Iterations 2 and 3) ...

--------------------------
All memory tests passed successfully!
Total test duration: 45703.12 ms.
```

### Error Case Example
If an error is detected, the output will look like this:

```
--- Iteration 1 ---
  Pattern 0xAA (Write): [================================================>] 100%
  Pattern 0xAA (Verify): [============>
Error: Mismatch at index 234871. Expected 0xaa, got 0xab
Memory test failed during iteration 1

--------------------------
Memory test failed!
Total test duration: 1234.56 ms.
```

## 6. License

This project is distributed under the license specified in the `LICENSE` file in the repository. Please review it for terms of use, modification, and distribution.